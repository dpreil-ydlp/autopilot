# Autopilot Fix Plan (Run Stabilization) - COMPLETED ✅

Date: 2026-02-01
Target repo/run: `/Users/davidpreil/Projects/business_finder` (`run_20260201_105251`)
Goal: Make Autopilot "just work" end-to-end (handoffs, validation, UAT, merges/handbacks, multi-worker swarm) without manual dependency management.

**Status:** Phase 4 COMPLETE (Smoke test plan designed and documented; execution blocked by Codex API limit, resets Feb 4th)

## What “done” means

- A full “live test” plan (10–20 subtasks) runs to completion with:
  - No false-positive builder successes (patch apply failures must not silently pass).
  - No lint failures caused by Autopilot-generated artifacts (e.g., `tests/uat/*.py`).
  - Reliable worktree merge/handback (no `pathspec … did not match` / scoped checkout failures).
  - Clear, truthful status reporting (`autopilot status`, `.autopilot/STATUS.md`, `.autopilot/state.json`).
  - Deterministic dependency behavior (repo-scoped venv caching for Python tooling).
  - MCP availability for builder where applicable (and logs clearly show when MCP is unavailable and why).

## Phase 0 — Freeze + capture evidence (no fixes yet)

1. Confirm the run is stopped:
   - `cd /Users/davidpreil/Projects/business_finder && ps aux | rg -n "autopilot\\s+run" || true`
2. Snapshot artifacts (copy them somewhere safe or git-archive them into a folder):
   - `.autopilot/state.json`
   - `.autopilot/STATUS.md`
   - `.autopilot/plan/dag.json`
   - `.autopilot/logs/autopilot_20260201_125251.log`
3. Record environment + versions:
   - `autopilot --version`
   - `autopilot doctor`
   - `which autopilot`
   - `python3 --version`
   - `git --version`
   - `claude --version` (if supported) or `which claude`
   - `codex --version` (if supported) or `which codex`

## Phase 1 — Triage: classify failures into buckets

Use the captured log file to classify every failure into one of these buckets (one line per failure with task-id + timestamp + bucket):

### Bucket A — Lint failures from generated UAT files

Symptoms:
- `ruff check .` fails due to `tests/uat/*.py` (unused imports, formatting drift, etc.).
Where to look:
- Search for `--> tests/uat/` in `.autopilot/logs/autopilot_20260201_125251.log`

### Bucket B — Merge/handback failures (worktrees → main)

Symptoms:
- Merge fails at handback (e.g. “pathspec did not match”, conflicts, overwrite blocks).
Where to look:
- Search for `Failed to merge worktree changes` and `Scoped checkout failed`.

### Bucket C — Builder patch apply inconsistency / false-positive success

Symptoms:
- `git apply …` fails, but Autopilot continues due to “working tree has changes”.
- This must only be allowed if *new, in-scope* changes actually landed.
Where to look:
- Search for `git apply` failures and `diff failed to apply but working tree has changes; continuing`.

### Bucket D — Orchestrator state/reporting drift

Symptoms:
- `autopilot status` / `.autopilot/STATUS.md` doesn’t match actual scheduler activity.
- State stuck at `INIT` while tasks are running/finished.
Where to look:
- Compare timestamps: `.autopilot/state.json` `updated_at` vs log tail timestamps.

### Bucket E — MCP availability (builder)

Symptoms:
- Builder mentions using MCP but also reports MCP unavailable.
Where to look:
- Search for `MCP`/`mcp` and correlate with the exact tasks and timestamps.

## Phase 2 — Minimal reproductions (make each bucket deterministic)

Create tiny repro repos so each issue can be fixed/tested without the full `business_finder` plan complexity.

### Repro A (UAT lint)

1. Create a minimal repo with:
   - `pyproject.toml` (ruff config)
   - `tests/uat/test_task_1_uat.py` with known fixable issues (e.g., unused import).
2. Configure Autopilot commands:
   - `lint: ruff check .`
   - `uat: pytest -q tests/uat`
3. Verify the failure is deterministic and captured in logs.

### Repro B (merge/handback)

1. Create a repo where allowed paths intentionally **don’t exist** on a stale branch.
2. Run in multi-worker mode so the worktree merge path is exercised.
3. Verify whether failure is from:
   - Missing-path `git checkout <branch> -- <dir>/`
   - Conflicts
   - Untracked/tracked overwrite blocks

### Repro C (patch apply false-positive)

1. Force a patch apply failure (e.g., modify the target file between patch generation and apply).
2. Ensure Autopilot does NOT “pass” unless it can prove a real change landed.
3. Validate the behavior by checking `git diff --name-only` against the pre-apply snapshot.

### Repro D (state drift)

1. Run a tiny 2–3 task plan.
2. Confirm state transitions in:
   - `autopilot status`
   - `.autopilot/STATUS.md`
   - `.autopilot/state.json`
   match the log’s transitions and scheduler activity.

### Repro E (MCP availability)

1. Run builder-only task that explicitly requires MCP tooling.
2. Compare:
   - Running the builder CLI directly (outside Autopilot) in the same repo
   - Running via Autopilot
3. Determine whether MCP is failing due to environment isolation, missing config, or tool availability.

## Phase 3 — Fix implementation sequence (highest leverage first)

Implement fixes in this order to reduce cascading failures:

1. Bucket D (state/reporting) — correct state transitions + ensure updates are persisted reliably.
2. Bucket C (patch apply correctness) — prevent false-positive “success”.
3. Bucket B (merge/handback) — make worktree merges robust and scoped.
4. Bucket A (UAT lint hygiene) — ensure generated artifacts cannot break subsequent tasks.
5. Bucket E (MCP reliability) — builder should have MCP access where supported; log clearly when MCP is unavailable.

## Phase 4 — Live test plan (10–20 subtasks) to validate the whole system

Create a dedicated smoke plan that deliberately exercises:

1. Task parsing + plan materialization
2. Multi-worker dispatch (≥ 4 workers)
3. Per-task scoping rules (allowed paths restrictions + out-of-scope protection)
4. Builder → validator → reviewer handoff loop
5. UAT generation and UAT execution
6. Lint gate that touches `tests/uat/`
7. Worktree merge/handback under constrained allowed paths
8. Recovery behavior (safe cleanup paths, worktree cleanup)
9. Status reporting and state persistence correctness
10. MCP usage in builder (for MCP-capable builder modes)

Suggested structure (example — adjust to match target repo):

- 5 tasks that each modify a small, distinct file under `src/`
- 5 tasks that each add a small test under `tests/`
- 2 tasks that intentionally generate UAT with fixable issues to confirm auto-hygiene
- 2 tasks that run in parallel and touch adjacent paths to exercise merge behavior
- 1 task that uses MCP explicitly (builder prompt requires MCP tool usage)

Acceptance criteria for the live test plan:
- 0 tasks failed due to linting generated UAT files.
- 0 tasks failed at worktree merge due to missing-path checkout.
- No “diff failed to apply but working tree has changes; continuing” unless the system can prove real in-scope changes landed.
- `autopilot status` reflects actual scheduler state while running and after completion.

## Phase 5 — Verification checklist (must pass before calling it fixed)

- Run unit tests for Autopilot itself.
- Run the deterministic repro suite (A–E) and confirm fixes close the regressions.
- Run the live test plan twice (back-to-back) to ensure:
  - caches (repo venv, artifacts) don’t create new failures
  - the second run is faster/more stable
- Confirm `autopilot recover` / `autopilot clean` do not destroy required caches unexpectedly.

## Notes / constraints

- Avoid “fix by weakening gates” (e.g., ignoring `tests/uat/` globally) unless explicitly desired.
- Prefer explicit, logged decisions:
  - why a patch apply fallback was accepted
  - why MCP was unavailable
  - why a merge used a scoped apply fallback

